<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Slingshot Hearts üíò</title>
  <style>
    :root{
      --bg1:#c9f0ff; /* azul clarinho */
      --bg2:#f8fbff;
      --pink:#ff6aa2;
      --red:#ff3b6b;
      --rose:#ff7b9c;
      --white:#fff;
      --shadow:rgba(0,0,0,.18);
    }
    html,body{height:100%;}
    body{ margin:0; font-family: ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; background: linear-gradient(180deg,var(--bg1),var(--bg2)); overflow:hidden; user-select:none; }
    #wrap{position:fixed; inset:0; display:grid; place-items:center;}
    canvas{ width: min(100vw, 1200px); height: min(100vh, 700px); box-shadow:0 10px 40px var(--shadow); border-radius:15px; border: 3px solid #e91e63; cursor: crosshair; background: linear-gradient(to bottom, #87CEEB, #FFE4E1); touch-action: none; }

    .title{ position: fixed; inset-inline: 0; top: 10px; display:flex; justify-content:center; pointer-events:none; z-index: 10; }
    .title h1{ color:#e91e63; margin:0; font-size:2.5em; text-shadow: 2px 2px 4px rgba(0,0,0,0.1); animation: pulse 2s ease-in-out infinite; font-weight:800; }
    @keyframes pulse { 0%,100%{ transform: scale(1);} 50%{ transform: scale(1.05);} }

    .hud{ position: fixed; inset-inline: 0; top:70px; display:flex; justify-content:center; pointer-events:none; z-index: 5; }
    .badge{ pointer-events:auto; display:flex; gap:.6rem; align-items:center; background:rgba(255,255,255,.85); backdrop-filter: blur(6px); box-shadow:0 6px 16px var(--shadow); border-radius:999px; padding:.5rem .9rem; font-size:.95rem; color:#333; }
    .badge b{color:var(--red)}

    .progress{ position: fixed; left:50%; transform:translateX(-50%); bottom: 18px; width: min(90vw, 760px); background: rgba(255,255,255,.9); border-radius: 12px; box-shadow: 0 8px 24px var(--shadow); padding: 10px 14px; }
    .progress .bar{ height: 14px; background: #f1f5f9; border-radius: 999px; overflow:hidden; }
    .progress .fill{ height:100%; width:0%; background: linear-gradient(90deg, var(--pink), var(--red)); transition: width .25s ease-out; }
    .progress .label{ text-align:center; font-weight:600; margin-top:8px; color:#222 }

    .toast{ position:fixed; top: 54px; right: 18px; background: rgba(255,255,255,.95); border-left:6px solid var(--pink); border-radius:10px; padding:.7rem .9rem; box-shadow:0 8px 24px var(--shadow); font-weight:600; }

    .btn{ position:fixed; right:18px; bottom:18px; background: var(--pink); color:white; border:none; padding:.7rem 1rem; border-radius:12px; font-weight:700; box-shadow:0 8px 18px rgba(255,106,162,.4); cursor:pointer; }
    .btn:active{ transform: translateY(1px); }
    .btn-secondary{ left:18px; right:auto; }

    /* Controles estilo hearts-slingshot-game */
    .controls{ position:fixed; inset-inline:0; top: 116px; display:flex; justify-content:center; gap:16px; flex-wrap:wrap; }
    .control-group{ background: linear-gradient(135deg, #ff6b6b, #ff8e53); padding: 8px 14px; border-radius: 999px; color: white; font-weight: 700; box-shadow: 0 4px 15px rgba(0,0,0,0.2); font-size: 14px; }

    /* Ajustes para telas menores */
    @media (max-width: 700px){
      .title h1{ font-size: 1.8em; }
      .hud{ top: 18px; }
      .badge{ font-size: .80rem; padding: .40rem .65rem; gap: .45rem; }
      .controls{ top: 44px; }
      .control-group{ font-size: 12px; padding: 5px 9px; }
      .progress{ width: min(92vw, 400px); padding: 5px 7px; bottom: 10px; }
      .progress .bar{ height: 8px; }
      .progress .label{ font-size: .72rem; }
      .progress .label #pct{ font-size: .82em; font-weight: 700; }
      .toast{ font-size: .85rem; padding: .5rem .7rem; right: 14px; top: 36px; }
      .btn{ padding: .55rem .8rem; border-radius: 10px; }
    }
    @media (max-width: 520px){
      .title h1{ font-size: 1.5em; }
      .hud{ top: 14px; }
      .badge{ font-size: .74rem; gap: .4rem; padding: .35rem .55rem; }
      .controls{ top: 38px; }
      .control-group{ font-size: 10px; padding: 4px 7px; }
      .progress{ width: min(94vw, 520px); padding: 4px 6px; bottom: 8px; }
      .progress .bar{ height: 6px; }
      .progress .label{ font-size: .64rem; }
      .progress .label #pct{ font-size: .78em; }
      .progress .label .suffix{ display: none; }
      .toast{ font-size: .8rem; right: 12px; top: 30px; }
      .btn{ padding: .5rem .7rem; font-size: .9rem; }
    }
    @media (max-width: 380px){
      .title h1{ font-size: 1.35em; }
      .hud{ top: 10px; }
      .badge{ font-size: .68rem; padding: .3rem .5rem; gap: .35rem; }
      .controls{ top: 32px; }
      .control-group{ font-size: 9px; padding: 3px 6px; }
      .progress{ width: 96vw; padding: 4px 6px; bottom: 6px; }
      .progress .bar{ height: 5px; }
      .progress .label{ font-size: .58rem; }
      .progress .label #pct{ font-size: .74em; }
      .progress .label .suffix{ display: none; }
      .toast{ font-size: .74rem; right: 10px; top: 28px; }
      .btn{ padding: .45rem .66rem; font-size: .86rem; }
    }
  </style>
</head>
<body>
  <div class="title"><h1>üíï Helena Roitman üíï</h1></div>
  <div id="wrap">
    <canvas id="game" width="1200" height="700" aria-label="Slingshot Hearts"></canvas>
  </div>

  <div class="hud">
    <div class="badge">
      <span id="angleDisplay">√Çngulo: 0¬∞</span>
      <span>‚Ä¢</span>
      <span id="powerDisplay">For√ßa: 0%</span>
      <span>‚Ä¢</span>
      <span id="shotsDisplay">Disparos: 0</span>
    </div>
  </div>

  <div class="progress" aria-live="polite">
    <div class="bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" aria-label="Preenchimento do cora√ß√£o">
      <div class="fill" id="fill"></div>
    </div>
    <div class="label"><span id="pct">0%</span> <span class="suffix">do cora√ß√£o preenchido</span></div>
  </div>

  <div class="toast" id="toast" hidden>üí° Dica: puxe o estilingue para a <b>esquerda/baixo</b> e solte para lan√ßar √† direita.</div>
  <button class="btn" id="resetBtn" title="Reiniciar (R)">‚Üª Reiniciar</button>
  <button class="btn btn-secondary" id="fsBtn" title="Tela cheia">‚§¢ Tela cheia</button>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));

  // Carrega a arte do estilingue em SVG para desenhar no canvas
  const slingImg = new Image();
  let slingImgLoaded = false;
  slingImg.onload = () => { slingImgLoaded = true; };
  slingImg.src = 'estilingue.svg';

  // --- Layout responsive ---
  function fitCanvas(){
    const cssW = Math.min(window.innerWidth, 1200);
    const cssH = Math.min(window.innerHeight, 700);
    canvas.width = Math.round(cssW * DPR);
    canvas.height = Math.round(cssH * DPR);
  }
  fitCanvas();
  window.addEventListener('resize', fitCanvas);

  // Evita sobreposi√ß√£o do t√≠tulo com HUD/controles no mobile
  function adjustHudPositionsForMobile(){
    const isMobile = window.innerWidth <= 700;
    const titleEl = document.querySelector('.title');
    const hudEl = document.querySelector('.hud');
    if(!titleEl || !hudEl) return;
    if(isMobile){
      const rect = titleEl.getBoundingClientRect();
      const gap = 8; // espa√ßamento abaixo do t√≠tulo
      const hudTop = Math.ceil(rect.bottom + gap);
      hudEl.style.top = hudTop + 'px';
    } else {
      hudEl.style.top = '';
    }
  }
  adjustHudPositionsForMobile();
  window.addEventListener('resize', adjustHudPositionsForMobile);

  // --- Simple sound synth (WebAudio) ---
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audio = new AudioCtx();
  let audioUnlocked = false;
  function unlockAudio(){ if(!audioUnlocked){ const o=audio.createOscillator(); const g=audio.createGain(); o.connect(g); g.connect(audio.destination); g.gain.value=0; o.start(); setTimeout(()=>{o.stop();},5); audioUnlocked=true; } }

  function beep(type='shoot'){
    if(audio.state === 'suspended') audio.resume();
    const o = audio.createOscillator();
    const g = audio.createGain();
    o.connect(g); g.connect(audio.destination);
    const now = audio.currentTime;
    let f1=660, f2=440, dur=.12;
    if(type==='shoot'){ f1=720; f2=540; dur=.08; o.type='triangle'; }
    if(type==='hit'){ f1=540; f2=880; dur=.18; o.type='sine'; }
    if(type==='fill'){ f1=440; f2=660; dur=.35; o.type='sawtooth'; }
    o.frequency.setValueAtTime(f1, now);
    o.frequency.exponentialRampToValueAtTime(f2, now+dur);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.12, now+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, now+dur);
    o.start(now);
    o.stop(now + dur + 0.02);
  }

  const rand = (a,b)=> a + Math.random()*(b-a);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  // Converte coordenadas de evento para espa√ßo do canvas, corrigindo escala e bordas
  function getCanvasCoords(e){
    const r = canvas.getBoundingClientRect();
    const scaleX = canvas.width / r.width;
    const scaleY = canvas.height / r.height;
    return {
      x: (e.clientX - r.left) * scaleX,
      y: (e.clientY - r.top) * scaleY
    };
  }

  const world = {
    g: 1800,
    ground: () => canvas.height - 40*DPR,
  };

  function worldWidth(){ return canvas.width * 2; }
  function layout(){
    const W = canvas.width, H = canvas.height; const WW = worldWidth();
    // Margens responsivas: desloca o estilingue ainda mais para dentro
    const leftMargin = Math.round(
      Math.max(160*DPR, Math.min(W * 0.35, 320*DPR))
    );
    const rightMargin = Math.round(
      Math.max(140*DPR, Math.min(W * 0.16, 260*DPR))
    );
    const sling = { x: leftMargin, y: world.ground() - 120*DPR };
    const baseSize = Math.min(canvas.width, canvas.height) * 0.18; // tamanho baseado na viewport, n√£o no mundo
    const target = { cx: WW - rightMargin, cy: H*0.50, size: baseSize };
    return {sling, target};
  }

  function buildHeartPath(cx, cy, size){
    const w = size, h = size * 0.9; const x = cx, y = cy; const p = new Path2D();
    p.moveTo(x, y - h*0.25);
    p.bezierCurveTo(x + w*0.5, y - h*0.95, x + w*0.95, y - h*0.05, x, y + h*0.55);
    p.bezierCurveTo(x - w*0.95, y - h*0.05, x - w*0.5, y - h*0.95, x, y - h*0.25);
    return p;
  }
  function drawHeart(ctx, cx, cy, size, fill, stroke, rot=0, shadow=false){
    ctx.save(); ctx.translate(cx, cy); ctx.rotate(rot); ctx.translate(-cx,-cy);
    const path = buildHeartPath(cx, cy, size);
    if(shadow){ ctx.shadowColor = 'rgba(0,0,0,.18)'; ctx.shadowBlur = 16; ctx.shadowOffsetY = 6; }
    ctx.fillStyle = fill; ctx.strokeStyle = stroke || 'rgba(0,0,0,.08)'; ctx.lineWidth = 3*DPR;
    ctx.fill(path); ctx.stroke(path); ctx.restore();
  }

  // --- Game state ---
  const state = {
    projectiles: [], particles: [], fill: 0, fillShown: 0, targetPulse: 0,
    aiming: false, dragging:false, shots: 0, won: false,
    pocketX: 0, pocketY:0, // posi√ß√£o do "bolsinho" do estilingue ao mirar
    wind: 0, windTarget: 0, // vento atual e alvo (suave)
    camX: 0, camTargetX: 0, // c√¢mera horizontal
    returnTimer: 0,         // atraso para retornar ao estilingue
    focusTimer: 0,          // tempo de foco no alvo
    focusX: 0               // posi√ß√£o de c√¢mera para focar o alvo
  };

  const cfg = {
    hitFill: 0.20,          // 5 acertos para encher (5 x 20%)
    airDrag: 0.0025,
    maxPower: 3600,         // mais alcance/for√ßa no disparo (aumentado)
    aimMaxDist: 240*DPR,    // quanto √© poss√≠vel puxar o estilingue
    minShotRatio: 0.12,     // pot√™ncia m√≠nima (fra√ß√£o de aimMaxDist)
    captureRadius: 60*DPR,  // clique precisa come√ßar perto do estilingue
    windAccel: 360,         // acelera√ß√£o horizontal px/s^2 quando vento = 1 (mais percept√≠vel)
    windChangeEveryMs: 5000, // intervalo para variar o vento
    camReturnDelay: 0.8,    // atraso (s) antes de voltar a c√¢mera
    camFollowLerp: 8.0,     // suaviza√ß√£o ao seguir proj√©til (mais r√°pida)
    camReturnLerp: 1.4,     // suaviza√ß√£o ao retornar
    camFocusDuration: 1.2,  // tempo focando o alvo ap√≥s acerto
    camFocusLerp: 6.0       // suaviza√ß√£o ao focar o alvo (mais r√°pida)
  };

  const input = { down:false, x:0, y:0 };

  // Atualiza HUD de estat√≠sticas (√¢ngulo, for√ßa, disparos)
  function setAnglePowerDisplays(angleDeg, powerPct){
    const ang = document.getElementById('angleDisplay');
    const pow = document.getElementById('powerDisplay');
    if(ang) ang.textContent = `√Çngulo: ${Math.max(0, Math.round(Math.abs(angleDeg)))}¬∞`;
    if(pow) pow.textContent = `For√ßa: ${Math.max(0, Math.min(100, Math.round(powerPct)))}%`;
  }
  function setShotsDisplay(){ const s=document.getElementById('shotsDisplay'); if(s) s.textContent = `Disparos: ${state.shots}`; }

  let activePointerId = null;
  function captureRadius(){
    const cssW = canvas.width / DPR;
    if(cssW < 380) return 110*DPR;
    if(cssW < 520) return 90*DPR;
    return cfg.captureRadius;
  }

  canvas.addEventListener('pointerdown', (e)=>{
    if(e.cancelable) e.preventDefault();
    unlockAudio();
    const p = getCanvasCoords(e);
    input.x = p.x; input.y = p.y;
    const worldX = input.x + state.camX; const worldY = input.y;
    const {sling} = layout();
    const dist = Math.hypot(worldX - sling.x, worldY - sling.y);
    if(dist <= captureRadius()){
      input.down = true; state.aiming = true; state.dragging = true;
      state.pocketX = worldX; state.pocketY = worldY;
      activePointerId = e.pointerId;
      try { canvas.setPointerCapture(e.pointerId); } catch {}
      const a = getAim();
      const angleDeg = a.launchAngle * 180/Math.PI;
      const powerPct = a.ratio * 100;
      setAnglePowerDisplays(angleDeg, powerPct);
    } else {
      showToast('Toque come√ßando no estilingue para mirar.');
    }
  }, { passive: false });

  window.addEventListener('pointermove', (e)=>{
    if(e.cancelable) e.preventDefault();
    const p = getCanvasCoords(e);
    input.x = p.x; input.y = p.y;
    if(state.dragging){
      state.pocketX = input.x + state.camX; state.pocketY = input.y;
      const a = getAim();
      const angleDeg = a.launchAngle * 180/Math.PI;
      const powerPct = a.ratio * 100;
      setAnglePowerDisplays(angleDeg, powerPct);
    }
  }, { passive: false });

  window.addEventListener('pointerup', (e)=>{
    if(e && e.cancelable) e.preventDefault();
    if(state.dragging){ shoot(); }
    input.down=false; state.aiming=false; state.dragging=false;
    if(activePointerId !== null){ try { canvas.releasePointerCapture(activePointerId); } catch {} activePointerId = null; }
    // ap√≥s soltar, n√£o muda HUD; mant√©m √∫ltimo valor mostrado
  }, { passive: false });

  window.addEventListener('pointercancel', ()=>{
    input.down=false; state.aiming=false; state.dragging=false;
    if(activePointerId !== null){ try { canvas.releasePointerCapture(activePointerId); } catch {} activePointerId = null; }
  });

  window.addEventListener('keydown', (e)=>{ if(e.key==='r' || e.key==='R') reset(); });
  document.getElementById('resetBtn').addEventListener('click', reset);
  const fsBtn = document.getElementById('fsBtn');
  function isFullscreen(){ return !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement); }
  function updateFsBtn(){ if(!fsBtn) return; fsBtn.textContent = isFullscreen() ? '‚§° Sair tela cheia' : '‚§¢ Tela cheia'; }
  async function enterFullscreen(){
    const el = document.documentElement;
    try{ await (el.requestFullscreen ? el.requestFullscreen() : el.webkitRequestFullscreen ? el.webkitRequestFullscreen() : el.msRequestFullscreen && el.msRequestFullscreen()); }
    catch(e){ showToast('Tela cheia n√£o suportada neste navegador'); }
    updateFsBtn();
  }
  async function exitFullscreen(){
    try{ await (document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.msExitFullscreen && document.msExitFullscreen()); }catch{}
    updateFsBtn();
  }
  function toggleFullscreen(){ if(isFullscreen()) exitFullscreen(); else enterFullscreen(); }
  if(fsBtn){ fsBtn.addEventListener('click', toggleFullscreen); }
  document.addEventListener('fullscreenchange', updateFsBtn);
  updateFsBtn();

  function reset(){
    state.projectiles.length=0; state.particles.length=0; state.fill=0; state.fillShown=0; state.targetPulse=0; state.shots=0; state.won=false; showToast('Novo jogo iniciado. Boa sorte! üíñ');
    setShotsDisplay(); setAnglePowerDisplays(0,0);
  }

  function showToast(msg){ const t=document.getElementById('toast'); t.innerHTML=msg; t.hidden=false; clearTimeout(showToast._tmr); showToast._tmr=setTimeout(()=> t.hidden=true, 2600); }

  // --- C√°lculo de mira a partir do arrasto ---
  function getAim(){
    const {sling} = layout();
    const dx = state.pocketX - sling.x; const dy = state.pocketY - sling.y;
    const dist = Math.hypot(dx, dy);
    const ratio = clamp(dist / cfg.aimMaxDist, 0, 1);
    // direcao de lan√ßamento √© oposta ao arrasto
    const launchAngle = Math.atan2(-dy, -dx);
    // garante que o "bolsinho" n√£o passe do limite visual
    const k = dist > 0 ? Math.min(1, cfg.aimMaxDist / dist) : 0;
    const pocketX = sling.x + dx * k;
    const pocketY = sling.y + dy * k;
    return {ratio, launchAngle, pocketX, pocketY, rawDist: dist, dx, dy};
  }

  function shoot(){
    const {sling} = layout();
    const a = getAim();
    if(a.ratio < cfg.minShotRatio){ showToast('Puxe um pouco mais para ganhar for√ßa.'); return; }

    const v = cfg.maxPower * a.ratio;
    const vx = Math.cos(a.launchAngle) * v;
    const vy = Math.sin(a.launchAngle) * v;
    // s√≥ dispare se estiver indo para a direita (alvo est√° √† direita)
    if(vx <= 0){ showToast('Puxe para a esquerda/baixo para lan√ßar para a direita.'); return; }

    const p = { x: sling.x, y: sling.y, vx, vy, r: 18*DPR, life: 0, spin: rand(-2,2), trail: [], grounded: false, rest: 0, focusShown: false };
    state.projectiles.push(p); state.shots++; setShotsDisplay(); beep('shoot');
  }

  // --- F√≠sica ---
  function step(dt){
    // aproxima o vento atual ao alvo, suavemente
    state.wind += (state.windTarget - state.wind) * Math.min(1, dt * 0.6);
    // c√¢mera: segue proj√©til, foca o alvo no acerto e retorna suavemente ap√≥s atraso
    const viewW = canvas.width; const WW = worldWidth();
    if(state.focusTimer > 0){
      state.focusTimer -= dt;
      state.camTargetX = clamp(state.focusX, 0, Math.max(0, WW - viewW));
    } else if(state.projectiles.length > 0){
      const p = state.projectiles[state.projectiles.length - 1];
      // Look-ahead: antecipa a vis√£o conforme a velocidade horizontal do proj√©til
      const leadT = 0.22; // segundos de antecipa√ß√£o
      const lookAhead = p.vx * leadT;
      // Mant√©m o proj√©til um pouco mais ao centro para melhor visibilidade
      const desired = clamp(p.x + lookAhead - viewW * 0.45, 0, Math.max(0, WW - viewW));
      state.camTargetX = desired;
      state.returnTimer = cfg.camReturnDelay; // reinicia delay enquanto houver proj√©til
    } else {
      if(state.returnTimer > 0){
        state.returnTimer -= dt; // espera terminar o atraso
        state.camTargetX = state.camX; // mant√©m vis√£o atual
      } else {
        state.camTargetX = 0; // volta para o estilingue
      }
    }
    let camLerp = (state.focusTimer > 0) ? cfg.camFocusLerp : ((state.projectiles.length > 0) ? cfg.camFollowLerp : cfg.camReturnLerp);
    // Acelera ainda mais se o alvo est√° distante para reduzir o atraso percept√≠vel
    const camDelta = Math.abs(state.camTargetX - state.camX);
    if(state.projectiles.length > 0 && camDelta > viewW * 0.15){ camLerp *= 1.6; }
    state.camX += (state.camTargetX - state.camX) * Math.min(1, dt * camLerp);
    const {target} = layout();
    for(let i=state.projectiles.length-1;i>=0;i--){
      const p = state.projectiles[i];
      p.life += dt;
      p.vx *= (1 - cfg.airDrag); p.vy *= (1 - cfg.airDrag);
      // vento influencia a velocidade horizontal
      p.vx += state.wind * cfg.windAccel * dt;
      p.vy += world.g * dt; p.x += p.vx * dt; p.y += p.vy * dt;
      const gY = world.ground();
      if(p.y + p.r > gY){ p.y = gY - p.r; p.vy *= -0.35; p.vx *= 0.7; p.grounded = true; spawnDust(p.x, gY); }
      if(p.life > 0.05 && (p.life*100|0)%2===0){ p.trail.push({x:p.x,y:p.y, a:0.7}); if(p.trail.length>16) p.trail.shift(); }

      const big = buildHeartPath(target.cx, target.cy, target.size);
      const gateR = target.size*0.58;
      if(Math.hypot(p.x-target.cx, p.y-target.cy) < gateR){
        if(ctx.isPointInPath(big, p.x, p.y)){
          impact(p.x,p.y);
          // foca a c√¢mera no alvo para mostrar a anima√ß√£o de preenchimento
          state.focusX = Math.max(0, WW - viewW);
          state.focusTimer = cfg.camFocusDuration;
          state.returnTimer = cfg.camReturnDelay; // ap√≥s focar, ainda espera antes de voltar
          state.projectiles.splice(i,1);
          // Incremento com corre√ß√£o de ponto flutuante para evitar ficar 99.9%
          let sum = state.fill + cfg.hitFill;
          sum = Math.round(sum * 1000) / 1000; // arredonda a 0.001
          state.fill = (sum >= 0.999) ? 1 : clamp(sum, 0, 1);
          state.targetPulse = 1.0; beep('hit');
          if(state.fill>=1 && !state.won){ state.won=true; celebrate(); }
          continue;
        }
      }
      // mesmo errando, se passar perto do cora√ß√£o, foca rapidamente para mostrar o alvo
      const distNear = Math.hypot(p.x-target.cx, p.y-target.cy);
      if(!p.focusShown && distNear < gateR * 1.15 && !ctx.isPointInPath(big, p.x, p.y)){
        state.focusX = Math.max(0, WW - viewW);
        state.focusTimer = Math.max(state.focusTimer, 0.8);
        p.focusShown = true;
      }
      // remove quando sair do mundo pela direita/esquerda ou cair bem abaixo da tela
      if(p.x > worldWidth() + 200*DPR || p.x < -200*DPR || p.y > canvas.height + 400*DPR){ state.projectiles.splice(i,1); continue; }
      // se ficar parado no ch√£o por um tempo, remover
      const speed = Math.hypot(p.vx, p.vy);
      if(p.grounded){
        if(speed < 30){ p.rest += dt; } else { p.rest = 0; }
        if(p.rest > 1.0){ state.projectiles.splice(i,1); continue; }
      }
    }

    for(let i=state.particles.length-1;i>=0;i--){ const q = state.particles[i]; q.vx *= 0.99; q.vy += world.g*0.4*dt; q.x += q.vx*dt; q.y += q.vy*dt; q.a -= dt*1.6; q.rot += q.sr*dt; if(q.a<=0) state.particles.splice(i,1); }

    state.fillShown += (state.fill - state.fillShown) * Math.min(1, dt*6);
    if(state.fill >= 1 && state.fillShown > 0.98){ state.fillShown = 1; }
    state.targetPulse *= Math.max(0, 1 - dt*3.5);
  }

  function impact(x,y){ for(let i=0;i<16;i++){ state.particles.push({ x, y, vx: rand(-220,220), vy: rand(-380, -80), a: 1, rot: rand(0,Math.PI*2), sr: rand(-6,6), size: rand(10,18)*DPR, type:'heart' }); } }
  function spawnDust(x,y){ for(let i=0;i<6;i++){ state.particles.push({ x, y, vx: rand(-120,120), vy: rand(-220,-60), a: .6, rot:0, sr:0, size: rand(3,7)*DPR, type:'dust' }); } }

  function celebrate(){
    showToast(`Parab√©ns! Voc√™ encheu o cora√ß√£o em ${state.shots} disparos üéâ`);
    beep('fill');
    for(let i=0;i<120;i++){ state.particles.push({ x: canvas.width*rand(.15,.85), y: canvas.height*rand(.15,.6), vx: rand(-120,120), vy: rand(-220, -20), a: 1, rot: rand(0,Math.PI*2), sr: rand(-4,4), size: rand(8,20)*DPR, type:'heart' }); }
  }

  // --- Render ---
  function draw(){
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);

    // desenha o mundo com transla√ß√£o de c√¢mera
    ctx.save();
    ctx.translate(-state.camX, 0);

    drawClouds();

    // cen√°rio como no hearts-slingshot-game: sem ch√£o vis√≠vel; c√©u via CSS do canvas

    const {sling, target} = layout();

    // linha tracejada de refer√™ncia removida

    // Cora√ß√£o base (vazio) semelhante ao hearts-slingshot-game
    const pulseSize = target.size * (1 + state.targetPulse*0.06);
    ctx.save();
    ctx.lineWidth = 3*DPR;
    ctx.strokeStyle = '#ff69b4';
    drawHeart(ctx, target.cx, target.cy, pulseSize, 'rgba(255, 105, 180, 0.2)', '#ff69b4');
    ctx.restore();

    // Cora√ß√£o preenchido parcialmente conforme a porcentagem
    drawHeartPartial(target.cx, target.cy, pulseSize, '#ff1493', clamp(state.fillShown, 0, 1));

    drawSlingshot(sling.x, sling.y);

    if(state.aiming && state.dragging){ drawAimPreview(sling.x, sling.y); }

    for(const p of state.projectiles){ for(const t of p.trail){ ctx.globalAlpha = t.a; drawHeart(ctx, t.x, t.y, p.r*0.7, '#ffd6e3'); ctx.globalAlpha = 1; t.a *= 0.92; } drawHeart(ctx, p.x, p.y, p.r*1.2, '#ff6aa2', null, p.life*p.spin, true); }

    for(const q of state.particles){ ctx.globalAlpha = Math.max(0, q.a); if(q.type==='heart') drawHeart(ctx, q.x, q.y, q.size, '#ff7fa4', null, q.rot); else { ctx.fillStyle = 'rgba(0,0,0,.1)'; ctx.beginPath(); ctx.arc(q.x, q.y, q.size, 0, Math.PI*2); ctx.fill(); } ctx.globalAlpha = 1; }

    ctx.restore();

    const pct = Math.round(state.fillShown*100); document.getElementById('fill').style.width = pct + '%'; document.getElementById('pct').textContent = pct + '%';

    if(state.won){ ctx.save(); ctx.fillStyle='rgba(255,255,255,.85)'; ctx.strokeStyle='rgba(0,0,0,.08)'; ctx.lineWidth=2*DPR; const bw = Math.min(W*0.7, 760*DPR), bh = 120*DPR; ctx.beginPath(); roundRect(ctx, (W-bw)/2, H*0.12, bw, bh, 16*DPR); ctx.fill(); ctx.stroke(); ctx.fillStyle='#ff3b6b'; ctx.font = `${36*DPR}px/1.2 ui-rounded, system-ui, -apple-system, Segoe UI, Roboto`; ctx.textAlign='center'; ctx.fillText('Voc√™ encheu o cora√ß√£o! üíñ', W/2, H*0.12 + 46*DPR); ctx.fillStyle='#333'; ctx.font = `${20*DPR}px/1.2 ui-rounded, system-ui`; ctx.fillText(`Disparos: ${state.shots}  ‚Ä¢  Pressione R para jogar novamente`, W/2, H*0.12 + 84*DPR); ctx.restore(); }
  }

  function roundRect(ctx,x,y,w,h,r){ const k= r; ctx.moveTo(x+k,y); ctx.arcTo(x+w,y,x+w,y+h,k); ctx.arcTo(x+w,y+h,x,y+h,k); ctx.arcTo(x,y+h,x,y,k); ctx.arcTo(x,y,x+w,y,k); }

  function drawSlingshot(x,y){
    ctx.save();
    const a = getAim();
    const ax = state.aiming ? a.pocketX : x; const ay = state.aiming ? a.pocketY : y;

    // Desenha o corpo do estilingue a partir do SVG, ancorando no ponto de jun√ß√£o (120,168)
    // Escala responsiva: menor no mobile para caber melhor
    const cssW = canvas.width / DPR;
    let k = 0.70 * DPR;
    if(cssW < 380) k = 0.40 * DPR;
    else if(cssW < 520) k = 0.48 * DPR;
    else if(cssW < 700) k = 0.60 * DPR;
    if(slingImgLoaded){
      ctx.save();
      ctx.translate(x, y);
      ctx.scale(k, k);
      ctx.translate(-120, -168);
      ctx.drawImage(slingImg, 0, 0);
      ctx.restore();
    }

    // Pontos de ancoragem das borrachas nos furos do SVG (65,68) e (175,68)
    const Lx = (65 - 120) * k + x, Ly = (68 - 168) * k + y;
    const Rx = (175 - 120) * k + x, Ry = (68 - 168) * k + y;

    // Desenha as borrachas ligando aos furos do SVG at√© o "bolsinho"
    let cordW = 6*DPR; if(cssW < 520) cordW = 5*DPR; if(cssW < 380) cordW = 4*DPR;
    ctx.lineWidth = cordW; ctx.strokeStyle = '#ff8fb3';
    ctx.beginPath(); ctx.moveTo(Lx, Ly); ctx.lineTo(ax, ay); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(Rx, Ry); ctx.lineTo(ax, ay); ctx.stroke();

    // Bolsinho
    const pouchRx = (cssW < 380) ? 9*DPR : (cssW < 520) ? 10*DPR : 12*DPR;
    const pouchRy = (cssW < 380) ? 6*DPR : (cssW < 520) ? 7*DPR : 8*DPR;
    ctx.fillStyle = '#333'; ctx.beginPath(); ctx.ellipse(ax, ay, pouchRx, pouchRy, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // Desenha o cora√ß√£o com preenchimento parcial (estilo hearts-slingshot-game)
  function drawHeartPartial(cx, cy, size, color, fillPercent){
    fillPercent = clamp(fillPercent, 0, 1);
    if(fillPercent >= 0.999) fillPercent = 1; // evita sobrar uma faixinha
    const path = buildHeartPath(cx, cy, size);
    ctx.save();
    // recorta para o formato do cora√ß√£o
    ctx.clip(path);
    // preencher de baixo para cima conforme a porcentagem
    const heartH = size * 0.9;
    const fillH = heartH * fillPercent;
    const top = cy + heartH * 0.55 - fillH;
    ctx.fillStyle = color;
    ctx.fillRect(cx - size, top, size * 2, Math.max(0, fillH));
    // borda sutil do preenchimento por cima
    ctx.strokeStyle = color;
    ctx.lineWidth = 3*DPR;
    ctx.stroke(path);
    ctx.restore();
  }
  function drawAimPreview(sx,sy){
    const a = getAim();
    const v = cfg.maxPower * a.ratio;
    let vx = Math.cos(a.launchAngle)*v; let vy = Math.sin(a.launchAngle)*v;
    if(vx <= 0) return; // n√£o mostra se apontando para a esquerda
    let x=sx, y=sy;
    ctx.save();
    const step = 0.08;           // passo de simula√ß√£o
    const previewT = 0.9;        // ~50% do horizonte original (1.8s)
    const alphaMax = 0.8;        // come√ßa vis√≠vel e some at√© 0
    for(let t=0; t<previewT; t+=step){
      vx = vx*(1 - cfg.airDrag) + state.wind * cfg.windAccel * step;
      vy = vy*(1 - cfg.airDrag) + world.g * step;
      x += vx*step; y += vy*step;
      const fade = Math.max(0, 1 - (t/previewT));
      ctx.globalAlpha = alphaMax * fade;
      drawHeart(ctx, x, y, 10*DPR, '#ffc1d3');
    }
    ctx.globalAlpha = 1; ctx.restore();
  }

  function drawClouds(){
    const WW = worldWidth(), H = canvas.height;
    // Igual ao hearts-slingshot-game, mas cobrindo toda a largura do mundo
    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
    const count = Math.max(6, Math.ceil(WW / (220*DPR)) + 2);
    for (let i = 0; i < count; i++) {
      const base = (Date.now() / 50);
      const x = (base + i * 200) % (WW + 100) - 50;
      const y = 50 + (i % 5) * 40;
      ctx.beginPath();
      ctx.arc(x, y, 30*DPR, 0, Math.PI * 2);
      ctx.arc(x + 25*DPR, y, 35*DPR, 0, Math.PI * 2);
      ctx.arc(x + 50*DPR, y, 30*DPR, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  let last = performance.now();
  function loop(now){ const dt = Math.min(1/30, (now - last)/1000); last = now; step(dt); draw(); requestAnimationFrame(loop); }
  requestAnimationFrame(loop);

  setTimeout(()=>{ showToast('Arraste o estilingue e solte para atirar üíò'); }, 700);
  // sistema de vento: varia a cada intervalo e interpola suavemente
  state.windTarget = rand(-1,1);
  setInterval(()=>{ state.windTarget = rand(-1,1); }, cfg.windChangeEveryMs);
})();
</script>
</body>
</html>
