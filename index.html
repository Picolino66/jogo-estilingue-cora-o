<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mucho Amor</title>
  <link rel="icon" href="logo.svg" type="image/svg+xml" />
  <link id="favicon32" rel="icon" sizes="32x32" href="logo.svg" />
  <link id="appleIcon" rel="apple-touch-icon" href="logo.svg" />
  <link rel="mask-icon" href="logo.svg" color="#e91e63" />
  <style>
    :root{
      --bg1:#c9f0ff; /* azul clarinho */
      --bg2:#f8fbff;
      --pink:#ff6aa2;
      --red:#ff3b6b;
      --rose:#ff7b9c;
      --white:#fff;
      --shadow:rgba(0,0,0,.18);
    }
    html,body{height:100%;}
    body{ margin:0; font-family: ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; background: linear-gradient(180deg,var(--bg1),var(--bg2)); overflow:hidden; user-select:none; }
    #wrap{position:fixed; inset:0; display:grid; place-items:center;}
    canvas{ width: min(100vw, 1200px); height: min(100vh, 700px); box-shadow:0 10px 40px var(--shadow); border-radius:15px; border: 3px solid #e91e63; cursor: crosshair; background: linear-gradient(to bottom, #87CEEB, #FFE4E1); touch-action: none; }

    .title{ position: fixed; inset-inline: 0; top: 10px; display:flex; justify-content:center; pointer-events:none; z-index: 10; }
    .title h1{ color:#e91e63; margin:0; font-size:2.5em; text-shadow: 2px 2px 4px rgba(0,0,0,0.1); animation: pulse 2s ease-in-out infinite; font-weight:800; }
    @keyframes pulse { 0%,100%{ transform: scale(1);} 50%{ transform: scale(1.05);} }

    .hud{ position: fixed; inset-inline: 0; top:70px; display:flex; justify-content:center; pointer-events:none; z-index: 5; }
    .badge{ pointer-events:auto; display:flex; gap:.6rem; align-items:center; background:rgba(255,255,255,.85); backdrop-filter: blur(6px); box-shadow:0 6px 16px var(--shadow); border-radius:999px; padding:.5rem .9rem; font-size:.95rem; color:#333; }
    .badge b{color:var(--red)}

    .progress{ position: fixed; left:50%; transform:translateX(-50%); bottom: 18px; width: min(90vw, 760px); background: rgba(255,255,255,.9); border-radius: 12px; box-shadow: 0 8px 24px var(--shadow); padding: 10px 14px; }
    .progress .bar{ height: 14px; background: #f1f5f9; border-radius: 999px; overflow:hidden; }
    .progress .fill{ height:100%; width:0%; background: linear-gradient(90deg, var(--pink), var(--red)); transition: width .25s ease-out; }
    .progress .label{ text-align:center; font-weight:600; margin-top:8px; color:#222 }

    .toast{ position:fixed; top: 54px; right: 18px; background: rgba(255,255,255,.95); border-left:6px solid var(--pink); border-radius:10px; padding:.7rem .9rem; box-shadow:0 8px 24px var(--shadow); font-weight:600; }

    .btn{ position:fixed; right:18px; bottom:18px; background: var(--pink); color:white; border:none; padding:.7rem 1rem; border-radius:12px; font-weight:700; box-shadow:0 8px 18px rgba(255,106,162,.4); cursor:pointer; }
    .btn:active{ transform: translateY(1px); }
    .btn-secondary{ left:18px; right:auto; }

    /* Vencedor: overlay acima de tudo */
    .win-overlay{ position:fixed; inset-inline:0; top:12%; display:flex; justify-content:center; z-index:9999; }
    #winOverlay[hidden]{ display:none !important; }
    .win-overlay .card{ background: rgba(255,255,255,.92); backdrop-filter: blur(6px); border-left:6px solid var(--pink); border-radius:16px; padding: .9rem 1.2rem; box-shadow:0 10px 30px var(--shadow); text-align:center; }
    .win-overlay .win-title{ font-weight:800; color:#ff3b6b; font-size: clamp(18px, 3.4vw, 32px); text-shadow:none; animation:none; position:static; }
    .win-overlay .win-subtitle{ color:#333; font-weight:600; font-size: clamp(12px, 2.2vw, 18px); }

    /* Overlay de v√≠deo de presente */
    .video-overlay{ position:fixed; inset:0; background: rgba(0,0,0,0.6); display:flex; align-items:center; justify-content:center; z-index:10000; padding: 16px; opacity:0; visibility:hidden; pointer-events:none; transition: opacity .6s ease, visibility 0s linear .6s; }
    .video-overlay.show{ opacity:1; visibility:visible; pointer-events:auto; transition: opacity .6s ease, visibility 0s; }
    #videoOverlay[hidden]{ display:none !important; }
    .video-wrap{ position:relative; width: min(96vw, 900px); max-height: 90vh; display:flex; flex-direction:column; gap:10px; }
    .video-title{ color:#fff; font-weight:800; text-align:center; font-size: clamp(18px, 4vw, 36px); text-shadow: 0 2px 8px rgba(0,0,0,.5); }
    .video-wrap video{ width: 100%; max-height: 80vh; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,.35); background:#000; }
    .video-close{ position:absolute; top:-10px; right:-10px; background: rgba(0,0,0,.65); color:#fff; border:none; width:36px; height:36px; border-radius:999px; cursor:pointer; font-weight:800; box-shadow:0 6px 18px rgba(0,0,0,.35); }
    .video-close:active{ transform: translateY(1px); }

    /* Controles estilo hearts-slingshot-game */
    .controls{ position:fixed; inset-inline:0; top: 116px; display:flex; justify-content:center; gap:16px; flex-wrap:wrap; }
    .control-group{ background: linear-gradient(135deg, #ff6b6b, #ff8e53); padding: 8px 14px; border-radius: 999px; color: white; font-weight: 700; box-shadow: 0 4px 15px rgba(0,0,0,0.2); font-size: 14px; }

    /* Ajustes para telas menores */
    @media (max-width: 700px){
      .title h1{ font-size: 1.8em; }
      .hud{ top: 18px; }
      .badge{ font-size: .80rem; padding: .40rem .65rem; gap: .45rem; }
      .controls{ top: 44px; }
      .control-group{ font-size: 12px; padding: 5px 9px; }
      .progress{ width: min(92vw, 400px); padding: 5px 7px; bottom: 10px; }
      .progress .bar{ height: 8px; }
      .progress .label{ font-size: .72rem; }
      .progress .label #pct{ font-size: .82em; font-weight: 700; }
      .toast{ font-size: .85rem; padding: .5rem .7rem; right: 14px; top: 36px; }
      .btn{ padding: .55rem .8rem; border-radius: 10px; }
    }
    @media (max-width: 520px){
      .title h1{ font-size: 1.5em; }
      .hud{ top: 14px; }
      .badge{ font-size: .74rem; gap: .4rem; padding: .35rem .55rem; }
      .controls{ top: 38px; }
      .control-group{ font-size: 10px; padding: 4px 7px; }
      .progress{ width: min(94vw, 520px); padding: 4px 6px; bottom: 8px; }
      .progress .bar{ height: 6px; }
      .progress .label{ font-size: .64rem; }
      .progress .label #pct{ font-size: .78em; }
      .progress .label .suffix{ display: none; }
      .toast{ font-size: .8rem; right: 12px; top: 30px; }
      .btn{ padding: .5rem .7rem; font-size: .9rem; }
    }
    @media (max-width: 380px){
      .title h1{ font-size: 1.35em; }
      .hud{ top: 10px; }
      .badge{ font-size: .68rem; padding: .3rem .5rem; gap: .35rem; }
      .controls{ top: 32px; }
      .control-group{ font-size: 9px; padding: 3px 6px; }
      .progress{ width: 96vw; padding: 4px 6px; bottom: 6px; }
      .progress .bar{ height: 5px; }
      .progress .label{ font-size: .58rem; }
      .progress .label #pct{ font-size: .74em; }
      .progress .label .suffix{ display: none; }
      .toast{ font-size: .74rem; right: 10px; top: 28px; }
      .btn{ padding: .45rem .66rem; font-size: .86rem; }
    }
  </style>
</head>
<body>
  <div class="title"><h1>üíï Helena Roitman üíï</h1></div>
  <div id="wrap">
    <canvas id="game" width="1200" height="700" aria-label="Slingshot Hearts"></canvas>
  </div>

  <div class="hud">
    <div class="badge">
      <span id="angleDisplay">√Çngulo: 0¬∞</span>
      <span>‚Ä¢</span>
      <span id="powerDisplay">For√ßa: 0%</span>
      <span>‚Ä¢</span>
      <span id="shotsDisplay">Disparos: 0</span>
    </div>
  </div>

  <div class="progress" aria-live="polite">
    <div class="bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" aria-label="Preenchimento do cora√ß√£o">
      <div class="fill" id="fill"></div>
    </div>
    <div class="label"><span id="pct">0%</span> <span class="suffix">do cora√ß√£o preenchido</span></div>
  </div>

  <div class="toast" id="toast" hidden>üí° Dica: puxe o estilingue para a <b>esquerda/baixo</b> e solte para lan√ßar √† direita.</div>
  <button class="btn" id="resetBtn" title="Reiniciar (R)">‚Üª Reiniciar</button>
  <button class="btn btn-secondary" id="fsBtn" title="Tela cheia">‚§¢ Tela cheia</button>

  <!-- Overlay de vit√≥ria -->
  <div id="winOverlay" class="win-overlay" hidden>
    <div class="card">
      <div class="win-title">Voc√™ encheu o cora√ß√£o! üíñ</div>
      <div class="win-subtitle" id="winShots"></div>
    </div>
  </div>

  <!-- Overlay de v√≠deo do presente -->
  <div id="videoOverlay" class="video-overlay" hidden>
    <div class="video-wrap">
      <button id="videoClose" class="video-close" aria-label="Fechar v√≠deo">‚úï</button>
      <div class="video-title">Pode abrir o presente üíñ</div>
      <video id="giftVideo" src="video.mp4" playsinline controls preload="metadata"></video>
    </div>
  </div>

  <script>
  (() => {
  // Gera favicon PNG e apple-touch-icon a partir do SVG
  function setIconsFromSVG(){
    const src = 'logo.svg';
    const img = new Image();
    img.onload = () => {
      const makeIcon = (size)=>{
        const c = document.createElement('canvas'); c.width = size; c.height = size; const x = c.getContext('2d');
        x.clearRect(0,0,size,size);
        // desenha com contain e centralizado
        const scale = Math.min(size / img.width, size / img.height);
        const w = img.width * scale, h = img.height * scale;
        const dx = (size - w) / 2, dy = (size - h) / 2;
        x.drawImage(img, dx, dy, w, h);
        return c.toDataURL('image/png');
      };
      const fav32 = document.getElementById('favicon32') || document.createElement('link');
      fav32.id = 'favicon32'; fav32.rel = 'icon'; fav32.sizes = '32x32'; fav32.type = 'image/png'; fav32.href = makeIcon(32); document.head.appendChild(fav32);
      const apple = document.getElementById('appleIcon') || document.createElement('link');
      apple.id = 'appleIcon'; apple.rel = 'apple-touch-icon'; apple.sizes = '180x180'; apple.href = makeIcon(180); document.head.appendChild(apple);
    };
    img.src = src;
  }
  setIconsFromSVG();
  
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));

  // Carrega a arte do estilingue em SVG para desenhar no canvas
  const slingImg = new Image();
  let slingImgLoaded = false;
  slingImg.onload = () => { slingImgLoaded = true; };
  slingImg.src = 'estilingue.svg';

  // --- Layout responsive ---
  function fitCanvas(){
    const cssW = Math.min(window.innerWidth, 1200);
    const cssH = Math.min(window.innerHeight, 700);
    canvas.width = Math.round(cssW * DPR);
    canvas.height = Math.round(cssH * DPR);
  }
  fitCanvas();
  window.addEventListener('resize', fitCanvas);

  // Evita sobreposi√ß√£o do t√≠tulo com HUD/controles no mobile
  function adjustHudPositionsForMobile(){
    const isMobile = window.innerWidth <= 700;
    const titleEl = document.querySelector('.title');
    const hudEl = document.querySelector('.hud');
    if(!titleEl || !hudEl) return;
    if(isMobile){
      const rect = titleEl.getBoundingClientRect();
      const gap = 8; // espa√ßamento abaixo do t√≠tulo
      const hudTop = Math.ceil(rect.bottom + gap);
      hudEl.style.top = hudTop + 'px';
    } else {
      hudEl.style.top = '';
    }
  }
  adjustHudPositionsForMobile();
  window.addEventListener('resize', adjustHudPositionsForMobile);

  // --- Simple sound synth (WebAudio) ---
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audio = new AudioCtx();
  let audioUnlocked = false;
  function unlockAudio(){ if(!audioUnlocked){ const o=audio.createOscillator(); const g=audio.createGain(); o.connect(g); g.connect(audio.destination); g.gain.value=0; o.start(); setTimeout(()=>{o.stop();},5); audioUnlocked=true; } }

  function beep(type='shoot'){
    if(audio.state === 'suspended') audio.resume();
    const o = audio.createOscillator();
    const g = audio.createGain();
    o.connect(g); g.connect(audio.destination);
    const now = audio.currentTime;
    let f1=660, f2=440, dur=.12;
    if(type==='shoot'){ f1=720; f2=540; dur=.08; o.type='triangle'; }
    if(type==='hit'){ f1=540; f2=880; dur=.18; o.type='sine'; }
    if(type==='fill'){ f1=440; f2=660; dur=.35; o.type='sawtooth'; }
    o.frequency.setValueAtTime(f1, now);
    o.frequency.exponentialRampToValueAtTime(f2, now+dur);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.12, now+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, now+dur);
    o.start(now);
    o.stop(now + dur + 0.02);
  }

  const rand = (a,b)=> a + Math.random()*(b-a);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  // Converte coordenadas de evento para espa√ßo do canvas, corrigindo escala e bordas
  function getCanvasCoords(e){
    const r = canvas.getBoundingClientRect();
    const scaleX = canvas.width / r.width;
    const scaleY = canvas.height / r.height;
    return {
      x: (e.clientX - r.left) * scaleX,
      y: (e.clientY - r.top) * scaleY
    };
  }

  const world = {
    g: 1800,
    ground: () => canvas.height - 40*DPR,
  };

  function worldWidth(){ return canvas.width * 2; }
  function layout(){
    const W = canvas.width, H = canvas.height; const WW = worldWidth();
    // Margens responsivas: desloca o estilingue ainda mais para dentro
    const leftMargin = Math.round(
      Math.max(160*DPR, Math.min(W * 0.35, 320*DPR))
    );
    const rightMargin = Math.round(
      Math.max(140*DPR, Math.min(W * 0.16, 260*DPR))
    );
    const sling = { x: leftMargin, y: world.ground() - 120*DPR };
    const baseSize = Math.min(canvas.width, canvas.height) * 0.18; // tamanho baseado na viewport, n√£o no mundo
    const target = { cx: WW - rightMargin, cy: H*0.50, size: baseSize };
    return {sling, target};
  }

  function buildHeartPath(cx, cy, size){
    const w = size, h = size * 0.9; const x = cx, y = cy; const p = new Path2D();
    p.moveTo(x, y - h*0.25);
    p.bezierCurveTo(x + w*0.5, y - h*0.95, x + w*0.95, y - h*0.05, x, y + h*0.55);
    p.bezierCurveTo(x - w*0.95, y - h*0.05, x - w*0.5, y - h*0.95, x, y - h*0.25);
    return p;
  }
  function drawHeart(ctx, cx, cy, size, fill, stroke, rot=0, shadow=false){
    ctx.save(); ctx.translate(cx, cy); ctx.rotate(rot); ctx.translate(-cx,-cy);
    const path = buildHeartPath(cx, cy, size);
    if(shadow){ ctx.shadowColor = 'rgba(0,0,0,.18)'; ctx.shadowBlur = 16; ctx.shadowOffsetY = 6; }
    ctx.fillStyle = fill; ctx.strokeStyle = stroke || 'rgba(0,0,0,.08)'; ctx.lineWidth = 3*DPR;
    ctx.fill(path); ctx.stroke(path); ctx.restore();
  }

  // --- Game state ---
  const state = {
    projectiles: [], particles: [], fill: 0, fillShown: 0, targetPulse: 0,
    aiming: false, dragging:false, shots: 0, won: false,
    pocketX: 0, pocketY:0, // posi√ß√£o do "bolsinho" do estilingue ao mirar
    wind: 0, windTarget: 0, // vento atual e alvo (suave)
    windDir: 1,             // dire√ß√£o do vento (+1 direita, -1 esquerda)
    windBaseFactor: 1.0,    // fator base 0.8..1.2 para efeito de pot√™ncia
    cloudOffset: 0,         // deslocamento cumulativo das nuvens
    camX: 0, camTargetX: 0, // c√¢mera horizontal
    returnTimer: 0,         // atraso para retornar ao estilingue
    focusTimer: 0,          // tempo de foco no alvo
    focusX: 0               // posi√ß√£o de c√¢mera para focar o alvo
  };

  const cfg = {
    hitFill: 0.20,          // 5 acertos para encher (5 x 20%)
    airDrag: 0.0025,
    maxPower: 3600,         // mais alcance/for√ßa no disparo (aumentado)
    aimMaxDist: 240*DPR,    // quanto √© poss√≠vel puxar o estilingue
    minShotRatio: 0.12,     // pot√™ncia m√≠nima (fra√ß√£o de aimMaxDist)
    captureRadius: 60*DPR,  // clique precisa come√ßar perto do estilingue
    windAccelMax: 720,      // acelera√ß√£o horizontal px/s^2 quando vento = 1 (alto)
    windChangeEveryMs: 3000, // intervalo para variar o vento (3s)
    cloudBaseSpeed: 20,     // px/s base das nuvens
    cloudWindMax: 60,       // px/s adicionais com vento = 1
    camReturnDelay: 0.8,    // atraso (s) antes de voltar a c√¢mera
    camFollowLerp: 8.0,     // suaviza√ß√£o ao seguir proj√©til (mais r√°pida)
    camReturnLerp: 1.4,     // suaviza√ß√£o ao retornar
    camFocusDuration: 1.2,  // tempo focando o alvo ap√≥s acerto
    camFocusLerp: 6.0       // suaviza√ß√£o ao focar o alvo (mais r√°pida)
  };

  const input = { down:false, x:0, y:0 };

  // Atualiza HUD de estat√≠sticas (√¢ngulo, for√ßa, disparos)
  function setAnglePowerDisplays(angleDeg, powerPct){
    const ang = document.getElementById('angleDisplay');
    const pow = document.getElementById('powerDisplay');
    if(ang) ang.textContent = `√Çngulo: ${Math.max(0, Math.round(Math.abs(angleDeg)))}¬∞`;
    if(pow) pow.textContent = `For√ßa: ${Math.max(0, Math.min(100, Math.round(powerPct)))}%`;
  }
  function setShotsDisplay(){ const s=document.getElementById('shotsDisplay'); if(s) s.textContent = `Disparos: ${state.shots}`; }

  let activePointerId = null;
  function captureRadius(){
    const cssW = canvas.width / DPR;
    if(cssW < 380) return 110*DPR;
    if(cssW < 520) return 90*DPR;
    return cfg.captureRadius;
  }

  canvas.addEventListener('pointerdown', (e)=>{
    if(e.cancelable) e.preventDefault();
    unlockAudio();
    const p = getCanvasCoords(e);
    input.x = p.x; input.y = p.y;
    const worldX = input.x + state.camX; const worldY = input.y;
    const {sling} = layout();
    const dist = Math.hypot(worldX - sling.x, worldY - sling.y);
    if(dist <= captureRadius()){
      input.down = true; state.aiming = true; state.dragging = true;
      state.pocketX = worldX; state.pocketY = worldY;
      activePointerId = e.pointerId;
      try { canvas.setPointerCapture(e.pointerId); } catch {}
      const a = getAim();
      const angleDeg = a.launchAngle * 180/Math.PI;
      const powerPct = a.ratio * 100;
      setAnglePowerDisplays(angleDeg, powerPct);
    } else {
      showToast('Toque come√ßando no estilingue para mirar.');
    }
  }, { passive: false });

  window.addEventListener('pointermove', (e)=>{
    if(e.cancelable) e.preventDefault();
    const p = getCanvasCoords(e);
    input.x = p.x; input.y = p.y;
    if(state.dragging){
      state.pocketX = input.x + state.camX; state.pocketY = input.y;
      const a = getAim();
      const angleDeg = a.launchAngle * 180/Math.PI;
      const powerPct = a.ratio * 100;
      setAnglePowerDisplays(angleDeg, powerPct);
    }
  }, { passive: false });

  window.addEventListener('pointerup', (e)=>{
    if(e && e.cancelable) e.preventDefault();
    if(state.dragging){ shoot(); }
    input.down=false; state.aiming=false; state.dragging=false;
    if(activePointerId !== null){ try { canvas.releasePointerCapture(activePointerId); } catch {} activePointerId = null; }
    // ap√≥s soltar, n√£o muda HUD; mant√©m √∫ltimo valor mostrado
  }, { passive: false });

  window.addEventListener('pointercancel', ()=>{
    input.down=false; state.aiming=false; state.dragging=false;
    if(activePointerId !== null){ try { canvas.releasePointerCapture(activePointerId); } catch {} activePointerId = null; }
  });

  window.addEventListener('keydown', (e)=>{ if(e.key==='r' || e.key==='R') reset(); });
  document.getElementById('resetBtn').addEventListener('click', reset);
  const fsBtn = document.getElementById('fsBtn');
  function isFullscreen(){ return !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement); }
  function updateFsBtn(){ if(!fsBtn) return; fsBtn.textContent = isFullscreen() ? '‚§° Sair tela cheia' : '‚§¢ Tela cheia'; }
  async function enterFullscreen(){
    const el = document.documentElement;
    try{ await (el.requestFullscreen ? el.requestFullscreen() : el.webkitRequestFullscreen ? el.webkitRequestFullscreen() : el.msRequestFullscreen && el.msRequestFullscreen()); }
    catch(e){ showToast('Tela cheia n√£o suportada neste navegador'); }
    updateFsBtn();
  }
  async function exitFullscreen(){
    try{ await (document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.msExitFullscreen && document.msExitFullscreen()); }catch{}
    updateFsBtn();
  }
  function toggleFullscreen(){ if(isFullscreen()) exitFullscreen(); else enterFullscreen(); }
  if(fsBtn){ fsBtn.addEventListener('click', toggleFullscreen); }
  document.addEventListener('fullscreenchange', updateFsBtn);
  updateFsBtn();

  // Fecha o v√≠deo do presente com fade-out
  function closeVideoOverlay(){
    const vWrap = document.getElementById('videoOverlay');
    const video = document.getElementById('giftVideo');
    if(vWrap){
      vWrap.classList.remove('show');
      const onEnd = ()=>{ vWrap.hidden = true; vWrap.removeEventListener('transitionend', onEnd); };
      vWrap.addEventListener('transitionend', onEnd);
    }
    if(video){ try{ video.pause(); }catch{} }
  }
  const videoClose = document.getElementById('videoClose');
  if(videoClose){ videoClose.addEventListener('click', closeVideoOverlay); }
  const videoOverlay = document.getElementById('videoOverlay');
  if(videoOverlay){
    videoOverlay.addEventListener('click', (e)=>{ if(e.target === videoOverlay) closeVideoOverlay(); });
  }

  function reset(){
    state.projectiles.length=0; state.particles.length=0; state.fill=0; state.fillShown=0; state.targetPulse=0; state.shots=0; state.won=false; showToast('Novo jogo iniciado. Boa sorte! üíñ');
    setShotsDisplay(); setAnglePowerDisplays(0,0);
    const w = document.getElementById('winOverlay'); if(w) w.hidden = true;
    const vWrap = document.getElementById('videoOverlay'); const video = document.getElementById('giftVideo');
    if(vWrap){ vWrap.hidden = true; }
    if(video){ try{ video.pause(); }catch{} }
  }

  function showToast(msg){ const t=document.getElementById('toast'); t.innerHTML=msg; t.hidden=false; clearTimeout(showToast._tmr); showToast._tmr=setTimeout(()=> t.hidden=true, 2600); }

  // --- C√°lculo de mira a partir do arrasto ---
  function getAim(){
    const {sling} = layout();
    const dx = state.pocketX - sling.x; const dy = state.pocketY - sling.y;
    const dist = Math.hypot(dx, dy);
    const ratio = clamp(dist / cfg.aimMaxDist, 0, 1);
    // direcao de lan√ßamento √© oposta ao arrasto
    const launchAngle = Math.atan2(-dy, -dx);
    // garante que o "bolsinho" n√£o passe do limite visual
    const k = dist > 0 ? Math.min(1, cfg.aimMaxDist / dist) : 0;
    const pocketX = sling.x + dx * k;
    const pocketY = sling.y + dy * k;
    return {ratio, launchAngle, pocketX, pocketY, rawDist: dist, dx, dy};
  }

  function shoot(){
    const {sling} = layout();
    const a = getAim();
    if(a.ratio < cfg.minShotRatio){ showToast('Puxe um pouco mais para ganhar for√ßa.'); return; }

    const v = cfg.maxPower * a.ratio;
    let vx = Math.cos(a.launchAngle) * v;
    const vy = Math.sin(a.launchAngle) * v;
    // s√≥ dispare se estiver indo para a direita (alvo est√° √† direita)
    if(vx <= 0){ showToast('Puxe para a esquerda/baixo para lan√ßar para a direita.'); return; }

    // Aplica efeito do vento no lan√ßamento: at√© -20% (contra) ou +20% (a favor)
    const base = state.windBaseFactor || 1.0; // 0.8,0.9,1.0,1.1,1.2
    const launchFactor = (state.windDir > 0) ? Math.max(base, 1.0) : Math.min(base, 1.0);
    vx *= launchFactor;

    const p = { x: sling.x, y: sling.y, vx, vy, r: 18*DPR, life: 0, spin: rand(-2,2), trail: [], grounded: false, rest: 0, focusShown: false };
    state.projectiles.push(p); state.shots++; setShotsDisplay(); beep('shoot');
  }

  // --- F√≠sica ---
  function step(dt){
    // aproxima o vento atual ao alvo, suavemente (mais r√°pido para intervalos de 3s)
    state.wind += (state.windTarget - state.wind) * Math.min(1, dt * 1.6);
    // deslocamento das nuvens de acordo com o vento
    const cloudCycle = worldWidth() + 100;
    const cloudSpeed = cfg.cloudBaseSpeed + state.wind * cfg.cloudWindMax; // px/s
    state.cloudOffset = (state.cloudOffset + cloudSpeed * dt) % cloudCycle;
    if(state.cloudOffset < 0) state.cloudOffset += cloudCycle;
    // c√¢mera: segue proj√©til, foca o alvo no acerto e retorna suavemente ap√≥s atraso
    const viewW = canvas.width; const WW = worldWidth();
    if(state.focusTimer > 0){
      state.focusTimer -= dt;
      state.camTargetX = clamp(state.focusX, 0, Math.max(0, WW - viewW));
    } else if(state.projectiles.length > 0){
      const p = state.projectiles[state.projectiles.length - 1];
      // Look-ahead: antecipa a vis√£o conforme a velocidade horizontal do proj√©til
      const leadT = 0.22; // segundos de antecipa√ß√£o
      const lookAhead = p.vx * leadT;
      // Mant√©m o proj√©til um pouco mais ao centro para melhor visibilidade
      const desired = clamp(p.x + lookAhead - viewW * 0.45, 0, Math.max(0, WW - viewW));
      state.camTargetX = desired;
      state.returnTimer = cfg.camReturnDelay; // reinicia delay enquanto houver proj√©til
    } else {
      if(state.returnTimer > 0){
        state.returnTimer -= dt; // espera terminar o atraso
        state.camTargetX = state.camX; // mant√©m vis√£o atual
      } else {
        state.camTargetX = 0; // volta para o estilingue
      }
    }
    let camLerp = (state.focusTimer > 0) ? cfg.camFocusLerp : ((state.projectiles.length > 0) ? cfg.camFollowLerp : cfg.camReturnLerp);
    // Acelera ainda mais se o alvo est√° distante para reduzir o atraso percept√≠vel
    const camDelta = Math.abs(state.camTargetX - state.camX);
    if(state.projectiles.length > 0 && camDelta > viewW * 0.15){ camLerp *= 1.6; }
    state.camX += (state.camTargetX - state.camX) * Math.min(1, dt * camLerp);
    const {target} = layout();
    for(let i=state.projectiles.length-1;i>=0;i--){
      const p = state.projectiles[i];
      p.life += dt;
      p.vx *= (1 - cfg.airDrag); p.vy *= (1 - cfg.airDrag);
      // vento influencia a velocidade horizontal (acelera√ß√£o cont√≠nua)
      p.vx += state.wind * cfg.windAccelMax * dt;
      p.vy += world.g * dt; p.x += p.vx * dt; p.y += p.vy * dt;
      const gY = world.ground();
      if(p.y + p.r > gY){ p.y = gY - p.r; p.vy *= -0.35; p.vx *= 0.7; p.grounded = true; spawnDust(p.x, gY); }
      if(p.life > 0.05 && (p.life*100|0)%2===0){ p.trail.push({x:p.x,y:p.y, a:0.7}); if(p.trail.length>16) p.trail.shift(); }

      const big = buildHeartPath(target.cx, target.cy, target.size);
      const gateR = target.size*0.58;
      if(Math.hypot(p.x-target.cx, p.y-target.cy) < gateR){
        if(ctx.isPointInPath(big, p.x, p.y)){
          impact(p.x,p.y);
          // foca a c√¢mera no alvo para mostrar a anima√ß√£o de preenchimento
          state.focusX = Math.max(0, WW - viewW);
          state.focusTimer = cfg.camFocusDuration;
          state.returnTimer = cfg.camReturnDelay; // ap√≥s focar, ainda espera antes de voltar
          state.projectiles.splice(i,1);
          // Incremento com corre√ß√£o de ponto flutuante para evitar ficar 99.9%
          let sum = state.fill + cfg.hitFill;
          sum = Math.round(sum * 1000) / 1000; // arredonda a 0.001
          state.fill = (sum >= 0.999) ? 1 : clamp(sum, 0, 1);
          state.targetPulse = 1.0; beep('hit');
          if(state.fill>=1 && !state.won){ state.won=true; celebrate(); }
          continue;
        }
      }
      // mesmo errando, se passar perto do cora√ß√£o, foca rapidamente para mostrar o alvo
      const distNear = Math.hypot(p.x-target.cx, p.y-target.cy);
      if(!p.focusShown && distNear < gateR * 1.15 && !ctx.isPointInPath(big, p.x, p.y)){
        state.focusX = Math.max(0, WW - viewW);
        state.focusTimer = Math.max(state.focusTimer, 0.8);
        p.focusShown = true;
      }
      // remove quando sair do mundo pela direita/esquerda ou cair bem abaixo da tela
      if(p.x > worldWidth() + 200*DPR || p.x < -200*DPR || p.y > canvas.height + 400*DPR){ state.projectiles.splice(i,1); continue; }
      // se ficar parado no ch√£o por um tempo, remover
      const speed = Math.hypot(p.vx, p.vy);
      if(p.grounded){
        if(speed < 30){ p.rest += dt; } else { p.rest = 0; }
        if(p.rest > 1.0){ state.projectiles.splice(i,1); continue; }
      }
    }

    for(let i=state.particles.length-1;i>=0;i--){ const q = state.particles[i]; q.vx *= 0.99; q.vy += world.g*0.4*dt; q.x += q.vx*dt; q.y += q.vy*dt; q.a -= dt*1.6; q.rot += q.sr*dt; if(q.a<=0) state.particles.splice(i,1); }

    state.fillShown += (state.fill - state.fillShown) * Math.min(1, dt*6);
    if(state.fill >= 1 && state.fillShown > 0.98){ state.fillShown = 1; }
    state.targetPulse *= Math.max(0, 1 - dt*3.5);
  }

  function impact(x,y){ for(let i=0;i<16;i++){ state.particles.push({ x, y, vx: rand(-220,220), vy: rand(-380, -80), a: 1, rot: rand(0,Math.PI*2), sr: rand(-6,6), size: rand(10,18)*DPR, type:'heart' }); } }
  function spawnDust(x,y){ for(let i=0;i<6;i++){ state.particles.push({ x, y, vx: rand(-120,120), vy: rand(-220,-60), a: .6, rot:0, sr:0, size: rand(3,7)*DPR, type:'dust' }); } }

  function celebrate(){
    showToast(`Parab√©ns! Voc√™ encheu o cora√ß√£o em ${state.shots} disparos üéâ`);
    beep('fill');
    for(let i=0;i<120;i++){ state.particles.push({ x: canvas.width*rand(.15,.85), y: canvas.height*rand(.15,.6), vx: rand(-120,120), vy: rand(-220, -20), a: 1, rot: rand(0,Math.PI*2), sr: rand(-4,4), size: rand(8,20)*DPR, type:'heart' }); }
    // Exibe v√≠deo do presente com t√≠tulo
    const w = document.getElementById('winOverlay'); if(w) w.hidden = true;
    const vWrap = document.getElementById('videoOverlay');
    const video = document.getElementById('giftVideo');
    if(vWrap && video){
      vWrap.hidden = false;
      // ativa fade-in
      vWrap.classList.remove('show');
      requestAnimationFrame(()=>{ requestAnimationFrame(()=>{ vWrap.classList.add('show'); }); });
      try{ video.currentTime = 0; }catch{}
      const playAttempt = video.play();
      if(playAttempt && typeof playAttempt.catch === 'function'){
        playAttempt.catch(()=>{
          showToast('Toque para iniciar o v√≠deo');
          video.addEventListener('click', function onClick(){ video.play().catch(()=>{}); video.removeEventListener('click', onClick); }, { once:true });
        });
      }
    }
  }

  // --- Render ---
  function draw(){
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);

    // desenha o mundo com transla√ß√£o de c√¢mera
    ctx.save();
    ctx.translate(-state.camX, 0);

    drawClouds();

    // cen√°rio como no hearts-slingshot-game: sem ch√£o vis√≠vel; c√©u via CSS do canvas

    const {sling, target} = layout();

    // linha tracejada de refer√™ncia removida

    // Cora√ß√£o base (vazio) semelhante ao hearts-slingshot-game
    const pulseSize = target.size * (1 + state.targetPulse*0.06);
    ctx.save();
    ctx.lineWidth = 3*DPR;
    ctx.strokeStyle = '#ff69b4';
    drawHeart(ctx, target.cx, target.cy, pulseSize, 'rgba(255, 105, 180, 0.2)', '#ff69b4');
    ctx.restore();

    // Cora√ß√£o preenchido parcialmente conforme a porcentagem
    drawHeartPartial(target.cx, target.cy, pulseSize, '#ff1493', clamp(state.fillShown, 0, 1));

    drawSlingshot(sling.x, sling.y);

    if(state.aiming && state.dragging){ drawAimPreview(sling.x, sling.y); }

    for(const p of state.projectiles){ for(const t of p.trail){ ctx.globalAlpha = t.a; drawHeart(ctx, t.x, t.y, p.r*0.7, '#ffd6e3'); ctx.globalAlpha = 1; t.a *= 0.92; } drawHeart(ctx, p.x, p.y, p.r*1.2, '#ff6aa2', null, p.life*p.spin, true); }

    for(const q of state.particles){ ctx.globalAlpha = Math.max(0, q.a); if(q.type==='heart') drawHeart(ctx, q.x, q.y, q.size, '#ff7fa4', null, q.rot); else { ctx.fillStyle = 'rgba(0,0,0,.1)'; ctx.beginPath(); ctx.arc(q.x, q.y, q.size, 0, Math.PI*2); ctx.fill(); } ctx.globalAlpha = 1; }

    ctx.restore();

    const pct = Math.round(state.fillShown*100); document.getElementById('fill').style.width = pct + '%'; document.getElementById('pct').textContent = pct + '%';

    // Mensagem de vit√≥ria agora √© DOM overlay (winOverlay)
  }

  function roundRect(ctx,x,y,w,h,r){ const k= r; ctx.moveTo(x+k,y); ctx.arcTo(x+w,y,x+w,y+h,k); ctx.arcTo(x+w,y+h,x,y+h,k); ctx.arcTo(x,y+h,x,y,k); ctx.arcTo(x,y,x+w,y,k); }

  function drawSlingshot(x,y){
    ctx.save();
    const a = getAim();
    const ax = state.aiming ? a.pocketX : x; const ay = state.aiming ? a.pocketY : y;

    // Desenha o corpo do estilingue a partir do SVG, ancorando no ponto de jun√ß√£o (120,168)
    // Escala responsiva: menor no mobile para caber melhor
    const cssW = canvas.width / DPR;
    let k = 0.70 * DPR;
    if(cssW < 380) k = 0.40 * DPR;
    else if(cssW < 520) k = 0.48 * DPR;
    else if(cssW < 700) k = 0.60 * DPR;
    if(slingImgLoaded){
      ctx.save();
      ctx.translate(x, y);
      ctx.scale(k, k);
      ctx.translate(-120, -168);
      ctx.drawImage(slingImg, 0, 0);
      ctx.restore();
    }

    // Pontos de ancoragem das borrachas nos furos do SVG (65,68) e (175,68)
    const Lx = (65 - 120) * k + x, Ly = (68 - 168) * k + y;
    const Rx = (175 - 120) * k + x, Ry = (68 - 168) * k + y;

    // Desenha as borrachas ligando aos furos do SVG at√© o "bolsinho"
    let cordW = 6*DPR; if(cssW < 520) cordW = 5*DPR; if(cssW < 380) cordW = 4*DPR;
    ctx.lineWidth = cordW; ctx.strokeStyle = '#ff8fb3';
    ctx.beginPath(); ctx.moveTo(Lx, Ly); ctx.lineTo(ax, ay); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(Rx, Ry); ctx.lineTo(ax, ay); ctx.stroke();

    // Bolsinho
    const pouchRx = (cssW < 380) ? 9*DPR : (cssW < 520) ? 10*DPR : 12*DPR;
    const pouchRy = (cssW < 380) ? 6*DPR : (cssW < 520) ? 7*DPR : 8*DPR;
    ctx.fillStyle = '#333'; ctx.beginPath(); ctx.ellipse(ax, ay, pouchRx, pouchRy, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // Desenha o cora√ß√£o com preenchimento parcial (estilo hearts-slingshot-game)
  function drawHeartPartial(cx, cy, size, color, fillPercent){
    fillPercent = clamp(fillPercent, 0, 1);
    if(fillPercent >= 0.999) fillPercent = 1; // evita sobrar uma faixinha
    const path = buildHeartPath(cx, cy, size);
    ctx.save();
    // recorta para o formato do cora√ß√£o
    ctx.clip(path);
    // preencher de baixo para cima conforme a porcentagem
    const heartH = size * 0.9;
    const fillH = heartH * fillPercent;
    const top = cy + heartH * 0.55 - fillH;
    ctx.fillStyle = color;
    ctx.fillRect(cx - size, top, size * 2, Math.max(0, fillH));
    // borda sutil do preenchimento por cima
    ctx.strokeStyle = color;
    ctx.lineWidth = 3*DPR;
    ctx.stroke(path);
    ctx.restore();
  }
  function drawAimPreview(sx,sy){
    const a = getAim();
    const v = cfg.maxPower * a.ratio;
    let vx = Math.cos(a.launchAngle)*v; let vy = Math.sin(a.launchAngle)*v;
    if(vx <= 0) return; // n√£o mostra se apontando para a esquerda
    let x=sx, y=sy;
    ctx.save();
    const step = 0.08;           // passo de simula√ß√£o
    const previewT = 0.9;        // ~50% do horizonte original (1.8s)
    const alphaMax = 0.8;        // come√ßa vis√≠vel e some at√© 0
    for(let t=0; t<previewT; t+=step){
      vx = vx*(1 - cfg.airDrag) + state.wind * cfg.windAccelMax * step;
      vy = vy*(1 - cfg.airDrag) + world.g * step;
      x += vx*step; y += vy*step;
      const fade = Math.max(0, 1 - (t/previewT));
      ctx.globalAlpha = alphaMax * fade;
      drawHeart(ctx, x, y, 10*DPR, '#ffc1d3');
    }
    ctx.globalAlpha = 1; ctx.restore();
  }

  function drawClouds(){
    const WW = worldWidth(), H = canvas.height;
    // Igual ao hearts-slingshot-game, mas cobrindo toda a largura do mundo
    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
    const count = Math.max(6, Math.ceil(WW / (220*DPR)) + 2);
    for (let i = 0; i < count; i++) {
      const base = state.cloudOffset;
      const x = (base + i * 200) % (WW + 100) - 50;
      const y = 50 + (i % 5) * 40;
      ctx.beginPath();
      ctx.arc(x, y, 30*DPR, 0, Math.PI * 2);
      ctx.arc(x + 25*DPR, y, 35*DPR, 0, Math.PI * 2);
      ctx.arc(x + 50*DPR, y, 30*DPR, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  let last = performance.now();
  function loop(now){ const dt = Math.min(1/30, (now - last)/1000); last = now; step(dt); draw(); requestAnimationFrame(loop); }
  requestAnimationFrame(loop);

  setTimeout(()=>{ showToast('Arraste o estilingue e solte para atirar üíò'); }, 700);
  // sistema de vento: dire√ß√£o ¬± e for√ßa variando entre fatores 0.8..1.2 a cada 3s
  const WIND_FACTORS = [0.8, 0.9, 1.0, 1.1, 1.2];
  function pickWind(){
    const dir = Math.random() < 0.5 ? -1 : 1; // esquerda/direita
    const baseFactor = WIND_FACTORS[(Math.random() * WIND_FACTORS.length) | 0];
    state.windDir = dir;
    state.windBaseFactor = baseFactor;
    // converte fator em alvo de intensidade normalizado (0, 0.5, 1.0)
    const mag = Math.min(1, Math.abs(baseFactor - 1) / 0.2);
    state.windTarget = dir * mag;
  }
  pickWind();
  setInterval(pickWind, cfg.windChangeEveryMs);
})();
</script>
</body>
</html>
